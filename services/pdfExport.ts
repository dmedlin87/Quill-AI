import { jsPDF } from 'jspdf';
import { AnalysisResult } from '@/types';
import { ExportConfig, ExportData, ExportSection } from '@/types/export';

// Support both constructible and factory-style mocks in tests
const createPdf = (Ctor: any, options: { orientation: 'portrait' | 'landscape'; unit: string; format: string }) => {
  try {
    return new Ctor(options);
  } catch {
    return Ctor(options);
  }
};

const DEFAULT_MARGIN_X = 20;
const DEFAULT_MARGIN_Y = 20;
const STANDARD_MANUSCRIPT_MARGIN_MM = 25.4;
const TITLE_OFFSET = 60;
const LINE_HEIGHT_FACTOR = 1.5;
const FONT_SIZE_BODY = 12;
const FONT_SIZE_HEADING = 18;
const FONT_SIZE_TITLE = 24;

export class PDFExportService {
  private doc: jsPDF;
  private cursorY: number;
  private pageHeight: number;
  private pageWidth: number;
  private contentWidth: number;
  private marginX: number;
  private marginY: number;
  private activePreset: 'default' | 'standard_manuscript';

  constructor() {
    this.doc = createPdf(jsPDF as any, { orientation: 'portrait', unit: 'mm', format: 'a4' });
    this.pageHeight = this.doc.internal.pageSize.getHeight();
    this.pageWidth = this.doc.internal.pageSize.getWidth();
    this.marginX = DEFAULT_MARGIN_X;
    this.marginY = DEFAULT_MARGIN_Y;
    this.contentWidth = this.pageWidth - this.marginX * 2;
    this.cursorY = this.marginY;
    this.activePreset = 'default';
  }

  private isStandardManuscript(config: ExportConfig): boolean {
    return config.manuscriptOptions.preset === 'standard_manuscript';
  }

  private initializeDocument(config: ExportConfig) {
    const wantsStandard = this.isStandardManuscript(config);

    if (wantsStandard) {
      if (this.activePreset !== 'standard_manuscript') {
        this.doc = createPdf(jsPDF as any, { orientation: 'portrait', unit: 'mm', format: 'letter' });
      }
      this.marginX = STANDARD_MANUSCRIPT_MARGIN_MM;
      this.marginY = STANDARD_MANUSCRIPT_MARGIN_MM;
      this.activePreset = 'standard_manuscript';
    } else {
      if (this.activePreset !== 'default') {
        this.doc = createPdf(jsPDF as any, { orientation: 'portrait', unit: 'mm', format: 'a4' });
      }
      this.marginX = DEFAULT_MARGIN_X;
      this.marginY = DEFAULT_MARGIN_Y;
      this.activePreset = 'default';
    }

    this.pageHeight = this.doc.internal.pageSize.getHeight();
    this.pageWidth = this.doc.internal.pageSize.getWidth();
    this.contentWidth = this.pageWidth - this.marginX * 2;
    this.cursorY = this.marginY;
  }

  private getBodyFontFamily(config: ExportConfig) {
    return this.isStandardManuscript(config) ? 'courier' : 'helvetica';
  }

  public async generatePdf(data: ExportData, config: ExportConfig): Promise<void> {
    try {
      this.initializeDocument(config);
      this.renderTitlePage(data);

      config.sections.forEach((section) => this.renderSection(section, data, config));

      const fileName = config.filename ?? `${this.sanitizeFileName(data.title)}_export.pdf`;
      this.doc.save(fileName);
    } catch (error) {
      console.error('PDF Generation Failed:', error);
      throw new Error('Failed to generate PDF');
    }
  }

  private renderTitlePage(data: ExportData) {
    this.cursorY = TITLE_OFFSET;
    this.doc.setFont('helvetica', 'bold');
    this.doc.setFontSize(FONT_SIZE_TITLE);
    this.doc.text(data.title, this.pageWidth / 2, this.cursorY, { align: 'center' });

    this.cursorY += 20;
    this.doc.setFont('helvetica', 'normal');
    this.doc.setFontSize(14);
    this.doc.text(`By ${data.author}`, this.pageWidth / 2, this.cursorY, { align: 'center' });

    this.cursorY += 10;
    this.doc.setFontSize(10);
    this.doc.setTextColor(100);
    this.doc.text(`Generated by Quill AI • ${new Date().toLocaleDateString()}`, this.pageWidth / 2, this.cursorY, {
      align: 'center',
    });
    this.doc.setTextColor(0);
  }

  private renderSection(section: ExportSection, data: ExportData, config: ExportConfig) {
    this.doc.addPage();
    this.cursorY = this.marginY;

    this.doc.setFont(this.getBodyFontFamily(config), 'bold');
    this.doc.setFontSize(FONT_SIZE_HEADING);
    const sectionTitle = this.getSectionTitle(section);
    this.doc.text(sectionTitle, this.marginX, this.cursorY);
    this.cursorY += 10;

    this.doc.setFont(this.getBodyFontFamily(config), 'normal');
    this.doc.setFontSize(FONT_SIZE_BODY);

    switch (section) {
      case ExportSection.Manuscript:
        this.renderManuscript(data.content, config);
        break;
      case ExportSection.Characters:
        this.renderLore(data.lore);
        break;
      case ExportSection.WorldRules:
        this.renderWorldRules(data.lore);
        break;
      case ExportSection.AnalysisReport:
        this.renderAnalysis(data.analysis);
        break;
    }
  }

  private renderManuscript(content: string, config: ExportConfig) {
    const standard = this.isStandardManuscript(config);
    const fontSize = standard ? FONT_SIZE_BODY : FONT_SIZE_BODY * config.manuscriptOptions.fontScale;
    const text = config.manuscriptOptions.includeChapterTitles
      ? content
      : content.replace(/(?<=\n|^)Chapter[^\n]*\n?/gi, '');
    const lineHeightMultiplier = standard ? 2 : config.manuscriptOptions.lineHeight;
    const lineHeight = fontSize * lineHeightMultiplier * 0.3527;

    this.doc.setFontSize(fontSize);
    this.doc.setFont(this.getBodyFontFamily(config), 'normal');

    const segments = text.split('\f');

    segments.forEach((segment, segmentIndex) => {
      if (segmentIndex > 0) {
        this.doc.addPage();
        this.cursorY = this.marginY;
      }

      const lines = this.doc.splitTextToSize(segment, this.contentWidth);
      lines.forEach((line) => {
        this.checkPageBreak(lineHeight);
        this.doc.text(line, this.marginX, this.cursorY);
        this.cursorY += lineHeight;
      });
    });
  }

  private renderLore(lore: ExportData['lore']) {
    const characters = lore.characters || [];
    if (!characters.length) {
      this.ensureParagraph('No characters defined.');
      return;
    }

    characters.forEach((character) => {
      this.checkPageBreak(40);

      this.doc.setFont('helvetica', 'bold');
      this.doc.setFontSize(14);
      this.doc.text(character.name, this.marginX, this.cursorY);
      this.cursorY += 7;

      if (character.arc) {
        this.doc.setFont('helvetica', 'italic');
        this.doc.setFontSize(11);
        this.doc.setTextColor(100);
        this.doc.text(`Arc: ${character.arc}`, this.marginX, this.cursorY);
        this.doc.setTextColor(0);
        this.cursorY += 7;
      }

      this.doc.setFont('helvetica', 'normal');
      this.doc.setFontSize(11);
      this.renderWrappedText(character.bio || 'No biography.', 6);
      this.cursorY += 6;
    });
  }

  private renderWorldRules(lore: ExportData['lore']) {
    const rules = lore.worldRules || [];
    if (!rules.length) {
      this.ensureParagraph('No world rules defined.');
      return;
    }

    rules.forEach((rule) => {
      this.checkPageBreak(10);
      this.doc.text('•', this.marginX, this.cursorY);
      this.renderWrappedText(rule, 7, this.marginX + 5);
      this.cursorY += 3;
    });
  }

  private renderAnalysis(analysis: AnalysisResult | null | undefined) {
    if (!analysis) {
      this.ensureParagraph('No analysis data available.');
      return;
    }

    this.ensureSectionWithText('Executive Summary', analysis.summary);
    this.ensureSectionWithText('Strengths', analysis.strengths.join('\n'));
    this.ensureSectionWithText('Weaknesses', analysis.weaknesses.join('\n'));

    if (analysis.pacing) {
      this.ensureSectionWithText('Pacing Score', `Score: ${analysis.pacing.score}/10`);
      if (analysis.pacing.analysis) {
        this.ensureSectionWithText('Pacing Notes', analysis.pacing.analysis);
      }
    }

    if (analysis.plotIssues.length) {
      this.ensureSectionTitle('Plot Issues');
      analysis.plotIssues.forEach((issue) => {
        this.renderWrappedText(issue.issue, 6);
        this.renderWrappedText(`Location: ${issue.location}`, 5);
        this.renderWrappedText(`Suggestion: ${issue.suggestion}`, 5);
        this.cursorY += 4;
      });
    }

    if (analysis.generalSuggestions.length) {
      this.ensureSectionWithText('General Suggestions', analysis.generalSuggestions.join('\n'));
    }
  }

  private ensureSectionTitle(title: string) {
    this.checkPageBreak(12);
    this.doc.setFont('helvetica', 'bold');
    this.doc.setFontSize(13);
    this.doc.text(title, this.marginX, this.cursorY);
    this.cursorY += 7;
    this.doc.setFont('helvetica', 'normal');
  }

  private ensureSectionWithText(title: string, text?: string) {
    this.ensureSectionTitle(title);
    if (text) {
      this.renderWrappedText(text, 6);
    } else {
      this.ensureParagraph('None provided.');
    }
  }

  private ensureParagraph(content: string) {
    this.renderWrappedText(content, 6);
  }

  private renderWrappedText(text: string, lineHeight = 6, startX = this.marginX) {
    const lines = this.doc.splitTextToSize(text, this.contentWidth - (startX - this.marginX));
    lines.forEach((line) => {
      this.checkPageBreak(lineHeight);
      this.doc.text(line, startX, this.cursorY);
      this.cursorY += lineHeight;
    });
  }

  private checkPageBreak(heightNeeded: number) {
    if (this.cursorY + heightNeeded > this.pageHeight - this.marginY) {
      this.doc.addPage();
      this.cursorY = this.marginY;
    }
  }

  private getSectionTitle(section: ExportSection) {
    switch (section) {
      case ExportSection.Manuscript:
        return 'Manuscript';
      case ExportSection.Characters:
        return 'Character Profiles';
      case ExportSection.WorldRules:
        return 'World Rules';
      case ExportSection.AnalysisReport:
        return 'Analysis Report';
    }
  }

  private sanitizeFileName(value: string) {
    if (!value) return 'quill-export';
    return value.replace(/[^a-zA-Z0-9_-]/g, '_').toLowerCase();
  }
}

export const pdfExportService = new PDFExportService();
